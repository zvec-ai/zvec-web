---
title: Upsert
extendedTitle: Upsert Documents
apiReference: /api-reference/collection/#zvec.model.collection.Collection.upsert
---


import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';

`upsert()` works just like `insert()` ‚Äî it adds one or more new [documents](../../concepts/data-modeling/#documents) (`Doc`) to a [collection](../../collections/).

The key difference is that if a document with the same `id` already exists, it will be **overwritten**.

<Callout className="text-base" type="info">
    - Use `upsert()` if you want to overwrite an existing document (or don't mind replacing it).
    - Use `insert()` if you want to avoid accidentally overwriting a document ‚Äî `insert()` will fail if a document with the same id already exists.
</Callout>

<Callout className="text-base" type="idea">
  **Performance Tip**:  
  New vectors are initially buffered for fast ingestion. For optimal search performance, call [`optimize()`](../../collections/optimize/) after upserting a large batch of documents.
</Callout>

---

## Document `Doc`

Each `Doc` passed to `upsert()` must:

- Have an `id` (if a document with the same `id` already exists, it will be replaced)
- Provide data that matches the collection's [schema](../../collections/create/#step-1-define-the-schema):
  1. **Scalar fields** go in the `fields` dictionary (field names as keys)
  1. **Vector embeddings** go in the `vectors` dictionary (vector names as keys)
- You can omit `nullable` scalar fields if a document doesn't have a value for them

---

## Upsert a Single Document

Assume you already have a collection with the following schema:

- A scalar field: `text` (string)
- A [dense vector embedding](../../concepts/vector-embedding/#dense-vectors): `text_embedding` (4-dimensional FP32 vector)
  <Callout className="text-base" type="idea">
    The 4-dimensional vector is for demonstration only ‚Äî real-world embeddings are usually much larger.
  </Callout>

You've also opened the collection and have a `collection` object ready.

<Accordions type="single">
  <Accordion title="Code Example">

  ```python title="Open a collection"
  from centaurdb import db
  from centaurdb.model.param import CollectionOption, HnswIndexParam, InvertIndexParam
  from centaurdb.model.schema import FieldSchema, VectorSchema
  from centaurdb.typing import DataType, MetricType

  collection_schema = db.CollectionSchema(  # [!code highlight]
      name="example_collection",
      fields=[
          FieldSchema(
              name="text",
              data_type=DataType.STRING,
              index_param=InvertIndexParam(enable_range_optimization=False),
          ),
      ],
      vectors=[
          VectorSchema(
              name="text_embedding",
              data_type=DataType.VECTOR_FP32,
              dimension=4,
              index_param=HnswIndexParam(metric_type=MetricType.COSINE),
          ),
      ],
  )

  collection = db.open(                     # [!code highlight]
      path="/path/to/example/collection",
      option=CollectionOption(read_only=False, enable_mmap=True),
  )
  ```

  </Accordion>
</Accordions>

Now, upsert a document like this:

```python title="Upsert a document"
from centaurdb.model import Doc

# Create a document
doc = Doc(  # [!code highlight]
    id="text_1",  # ‚Üê must be unique
    vectors={
        "text_embedding": [0.1, 0.2, 0.3, 0.4],  # ‚Üê must match the vector name
                          # ‚Üë list of floats; list length = dimension (4)
    },
    fields={
        "text": "This is a sample text.",  # ‚Üê must match the scalar field name
    },
)

# Upsert the document
result = collection.upsert(doc)  # [!code highlight]
print(result)  # {"code": 0} means success
```

<Callout className="text-base" type="info">
  The `upsert()` method returns a `Status` object for single-document upsertion.
  - `{"code": 0}` indicates success.
  - Non-zero codes indicate failure.

  Successfully upserted documents are immediately available for querying üöÄ.
</Callout>

---

## Upsert a Batch of Documents

To upsert multiple documents at once, pass a list of `Doc` objects to `upsert()`.  
Each `Doc` is processed independently, and the method returns a list of `Status` objects ‚Äî one per document.

```python title="Upsert a batch of documents"
from centaurdb.model import Doc

result = collection.upsert(   # [!code highlight]
    [
        Doc(
            id="text_1",
            vectors={"text_embedding": [0.1, 0.2, 0.3, 0.4]},
            fields={"text": "This is a sample text."},
        ),
        Doc(
            id="text_2",
            vectors={"text_embedding": [0.4, 0.3, 0.2, 0.1]},
            fields={"text": "This is another sample text."},
        ),
        Doc(
            id="text_3",
            vectors={"text_embedding": [-0.1, -0.2, -0.3, -0.4]},
            fields={"text": "One more sample text."},
        ),
    ]
)

print(result) # [{"code":0}, {"code":0}, {"code":0}]
```

<Callout className="text-base" type="info">
  A failure in one document (e.g., missing a required field or invalid data type) does not stop the others from being upserted.  
  üîç **Always check each `Status` in the result list.**
</Callout>

---

## Upsert Documents with Sparse Vectors

Assume your collection includes a [sparse vector](../../concepts/vector-embedding/#sparse-vectors) named `sparse_embedding`.

<Accordions type="single">
  <Accordion title="Code Example">

  ```python title="Open a collection"
  from centaurdb import db
  from centaurdb.model.param import CollectionOption, HnswIndexParam
  from centaurdb.model.schema import VectorSchema
  from centaurdb.typing import DataType, MetricType

  collection_schema = db.CollectionSchema(  # [!code highlight]
      name="example_collection",
      vectors=[
          VectorSchema(
              name="sparse_embedding",
              data_type=DataType.SPARSE_VECTOR_FP32,
              index_param=HnswIndexParam(metric_type=MetricType.IP),
          ),
      ],
  )

  collection = db.open(                     # [!code highlight]
      path="/path/to/example/collection",
      option=CollectionOption(read_only=False, enable_mmap=True),
  )
  ```

  </Accordion>
</Accordions>

Upsert a document with a sparse vector like this:

```python title="Upsert a document with a sparse vector"
from centaurdb.model import Doc

result = collection.upsert(   # [!code highlight]
    Doc(
        id="text_1",
        vectors={
            "sparse_embedding": {
                42: 1.25,  # ‚Üê dimension 42 has weight 1.25
                1337: 0.8,  # ‚Üê dimension 1337 has weight 0.8
                2999: 0.63,  # ‚Üê dimension 1999 has weight 0.63
            }
        },
    )
)

print(result)  # {"code":0}
```

<Callout className="text-base" type="info">
  A sparse vector is represented as a dictionary `dict[int, float]`.  
  There is **no fixed dimension size** ‚Äî only non-zero dimensions need to be included.
</Callout>

---

## Upsert Documents with Multiple Fields and Vectors

Real-world applications often require collections with multiple scalar fields and vector embeddings.  
In this example, assume your collection includes the following schema:

- **Scalar fields**:
  1. `book_title` (string)
  1. `category` (array of strings)
  1. `publish_year` (32-bit integer)
- **Vector embeddings**:
  1. `dense_embedding`: a 768-dimensional dense vector
  1. `sparse_embedding`: a sparse vector

<Accordions type="single">
  <Accordion title="Code Example">

  ```python title="Open a collection"
  from centaurdb import db
  from centaurdb.model.param import CollectionOption, HnswIndexParam, InvertIndexParam
  from centaurdb.model.schema import FieldSchema, VectorSchema
  from centaurdb.typing import DataType, MetricType

  collection_schema = db.CollectionSchema(  # [!code highlight]
      name="example_collection",
      fields=[
          FieldSchema(
              name="book_title",
              data_type=DataType.STRING,
              index_param=InvertIndexParam(enable_range_optimization=False),
          ),
          FieldSchema(
              name="category",
              data_type=DataType.ARRAY_STRING,
          ),
          FieldSchema(
              name="publish_year",
              data_type=DataType.INT32,
              index_param=InvertIndexParam(enable_range_optimization=True),
          ),
      ],
      vectors=[
          VectorSchema(
              name="dense_embedding",
              data_type=DataType.VECTOR_FP32,
              dimension=768,
              index_param=HnswIndexParam(metric_type=MetricType.COSINE),
          ),
          VectorSchema(
              name="sparse_embedding",
              data_type=DataType.SPARSE_VECTOR_FP32,
              index_param=HnswIndexParam(metric_type=MetricType.IP),
          ),
      ],
  )

  collection = db.open(                     # [!code highlight]
      path="/path/to/example/collection",
      option=CollectionOption(read_only=False, enable_mmap=True),
  )
  ```

  </Accordion>
</Accordions>

Upsert a document with multiple fields and vectors like this:

```python title="Upsert a document with multiple fields and vectors"
from centaurdb import Doc

# Create a document
doc = Doc(                        # [!code highlight]
    id="book_1",
    vectors={
        "dense_embedding": [0.1 for _ in range(768)],   # ‚Üê use real embedding in practice
        "sparse_embedding": {42: 1.25, 1337: 0.8, 1999: 0.64},  # ‚Üê use real embedding in practice

    },
    fields={
        "book_title": "Gone with the Wind",  # ‚Üê string
        "category": ["Romance", "Classic Literature"],  # ‚Üê array of strings
        "publish_year": 1936,  # ‚Üê integer
    },
)

# Upsert the document
result = collection.upsert(doc)   # [!code highlight]
print(result)  # {"code": 0} means success
```
